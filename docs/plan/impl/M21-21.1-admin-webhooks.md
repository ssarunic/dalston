# M21 Task 21.1: Admin-Registered Webhooks - Implementation Plan

## Overview

This plan covers the full implementation of admin-registered webhook endpoints, replacing the per-job `webhook_url` approach with a persistent, observable delivery system.

**Specification:** [M21-admin-webhooks.md](../milestones/M21-admin-webhooks.md)
**Design decisions:** [ADR-007](../../decisions/ADR-007-admin-webhook-design.md)

## Goal

Replace per-job webhook URLs with admin-registered endpoints:

- CRUD API for webhook endpoint management (`/v1/webhooks`)
- Per-endpoint HMAC signing secrets (`whsec_` prefix)
- Persistent delivery with crash-resilient retries (PostgreSQL-backed)
- Delivery log with manual retry capability
- Backward compatibility for per-job `webhook_url`

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     DELIVERY FLOW                                            │
│                                                                              │
│   Event fires (job.completed / job.failed)                                   │
│         │                                                                    │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    Orchestrator Event Handler                        │   │
│   │                                                                      │   │
│   │   1. Query webhook_endpoints for tenant                             │   │
│   │      WHERE events @> ARRAY[event_type] AND is_active = true         │   │
│   │   2. INSERT webhook_deliveries row per matching endpoint            │   │
│   │   3. If job.webhook_url set: INSERT with url_override, no endpoint  │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│         │                                                                    │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    Delivery Worker (polling loop)                    │   │
│   │                                                                      │   │
│   │   SELECT ... FROM webhook_deliveries                                │   │
│   │   WHERE status = 'pending' AND next_retry_at <= now()               │   │
│   │   FOR UPDATE SKIP LOCKED                                            │   │
│   │   LIMIT 10                                                          │   │
│   │                                                                      │   │
│   │   For each:                                                         │   │
│   │     → Look up signing_secret from endpoint (or global for legacy)   │   │
│   │     → POST payload to url with HMAC signature                       │   │
│   │     → On 2xx: status = 'success'                                    │   │
│   │     → On failure: increment attempts, set next_retry_at             │   │
│   │     → On max attempts (5): status = 'failed'                        │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## File Structure

```
dalston/db/
└── models.py                          # Add WebhookEndpointModel, WebhookDeliveryModel

dalston/config.py                      # Add ALLOW_PER_JOB_WEBHOOKS setting

dalston/gateway/
├── api/v1/
│   ├── webhooks.py                    # New: /v1/webhooks router
│   └── router.py                      # Register webhooks router
├── dependencies.py                    # Add webhook service dependencies
├── models/
│   └── responses.py                   # Add webhook response models
└── services/
    ├── webhook.py                     # Modify: per-endpoint secret support
    └── webhook_endpoints.py           # New: CRUD service

dalston/orchestrator/
├── delivery.py                        # New: DeliveryWorker
└── main.py                            # Integrate delivery worker, change dispatch

dalston/gateway/api/v1/
└── transcription.py                   # Add ALLOW_PER_JOB_WEBHOOKS check

sdk/dalston_sdk/
└── webhook.py                         # Update docs for per-endpoint secrets

tests/
├── unit/
│   ├── test_webhook_endpoints.py      # New: CRUD service tests
│   └── test_delivery_worker.py        # New: delivery worker tests
└── integration/
    ├── test_webhook_admin_api.py      # New: API endpoint tests
    └── test_admin_webhooks_e2e.py     # New: full flow E2E tests
```

---

## Component Details

### 1. `dalston/db/models.py` — Database Models

Add two new models alongside the existing `JobModel`:

```python
class WebhookEndpointModel(Base):
    __tablename__ = "webhook_endpoints"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, server_default=func.gen_random_uuid()
    )
    tenant_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), ForeignKey("tenants.id"), nullable=False, index=True
    )
    url: Mapped[str] = mapped_column(Text, nullable=False)
    description: Mapped[str | None] = mapped_column(String(255), nullable=True)
    events: Mapped[list[str]] = mapped_column(ARRAY(String), nullable=False)
    signing_secret: Mapped[str] = mapped_column(Text, nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now()
    )


class WebhookDeliveryModel(Base):
    __tablename__ = "webhook_deliveries"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, server_default=func.gen_random_uuid()
    )
    endpoint_id: Mapped[uuid.UUID | None] = mapped_column(
        UUID(as_uuid=True), ForeignKey("webhook_endpoints.id", ondelete="CASCADE"),
        nullable=True,
    )
    job_id: Mapped[uuid.UUID | None] = mapped_column(
        UUID(as_uuid=True), ForeignKey("jobs.id", ondelete="SET NULL"), nullable=True
    )
    event_type: Mapped[str] = mapped_column(String(50), nullable=False)
    payload: Mapped[dict] = mapped_column(JSONB, nullable=False)
    url_override: Mapped[str | None] = mapped_column(Text, nullable=True)
    status: Mapped[str] = mapped_column(
        String(20), nullable=False, default="pending"
    )
    attempts: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    last_attempt_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )
    last_status_code: Mapped[int | None] = mapped_column(Integer, nullable=True)
    last_error: Mapped[str | None] = mapped_column(Text, nullable=True)
    next_retry_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )
```

Create Alembic migration with composite indexes:

```python
op.create_index(
    "ix_webhook_deliveries_status_retry",
    "webhook_deliveries",
    ["status", "next_retry_at"],
)
op.create_index(
    "ix_webhook_deliveries_endpoint_created",
    "webhook_deliveries",
    ["endpoint_id", sa.text("created_at DESC")],
)
```

---

### 2. `dalston/gateway/services/webhook_endpoints.py` — CRUD Service

```python
import secrets

ALLOWED_EVENTS = {"transcription.completed", "transcription.failed", "*"}

class WebhookEndpointService:
    async def create_endpoint(
        self, db: AsyncSession, tenant_id: UUID, url: str,
        events: list[str], description: str | None = None,
    ) -> tuple[WebhookEndpointModel, str]:
        validate_webhook_url(url)  # Reuse existing SSRF checks
        self._validate_events(events)
        raw_secret = f"whsec_{secrets.token_urlsafe(32)}"
        endpoint = WebhookEndpointModel(
            tenant_id=tenant_id, url=url, events=events,
            description=description, signing_secret=raw_secret,
        )
        db.add(endpoint)
        await db.commit()
        await db.refresh(endpoint)
        return endpoint, raw_secret

    async def list_endpoints(
        self, db: AsyncSession, tenant_id: UUID, is_active: bool | None = None,
    ) -> list[WebhookEndpointModel]:
        # Query with optional is_active filter, ORDER BY created_at DESC

    async def get_endpoint(
        self, db: AsyncSession, endpoint_id: UUID, tenant_id: UUID,
    ) -> WebhookEndpointModel | None:
        # Fetch by ID, verify tenant_id matches

    async def update_endpoint(
        self, db: AsyncSession, endpoint_id: UUID, tenant_id: UUID, **fields,
    ) -> WebhookEndpointModel | None:
        # Partial update. Re-validate url if changed. Re-validate events if changed.

    async def delete_endpoint(
        self, db: AsyncSession, endpoint_id: UUID, tenant_id: UUID,
    ) -> bool:
        # Hard delete. CASCADE handles delivery rows.

    async def rotate_secret(
        self, db: AsyncSession, endpoint_id: UUID, tenant_id: UUID,
    ) -> tuple[WebhookEndpointModel, str] | None:
        # Generate new whsec_ secret, return (model, raw_secret)

    async def list_deliveries(
        self, db: AsyncSession, endpoint_id: UUID, tenant_id: UUID,
        status: str | None = None, limit: int = 20, offset: int = 0,
    ) -> tuple[list[WebhookDeliveryModel], int]:
        # Verify endpoint belongs to tenant, query deliveries

    async def retry_delivery(
        self, db: AsyncSession, endpoint_id: UUID, delivery_id: UUID,
        tenant_id: UUID,
    ) -> WebhookDeliveryModel | None:
        # Verify ownership chain, verify status='failed',
        # reset to status='pending', next_retry_at=now()

    def _validate_events(self, events: list[str]) -> None:
        invalid = set(events) - ALLOWED_EVENTS
        if invalid:
            raise ValueError(f"Invalid event types: {invalid}")
```

---

### 3. `dalston/gateway/api/v1/webhooks.py` — API Router

```python
router = APIRouter(prefix="/webhooks", tags=["webhooks"])

# Request models
class CreateWebhookRequest(BaseModel):
    url: HttpUrl
    events: list[str]
    description: str | None = None

class UpdateWebhookRequest(BaseModel):
    url: HttpUrl | None = None
    events: list[str] | None = None
    description: str | None = None
    is_active: bool | None = None

# Response models
class WebhookEndpointResponse(BaseModel):
    id: UUID
    url: str
    events: list[str]
    description: str | None
    is_active: bool
    created_at: datetime
    updated_at: datetime

class WebhookEndpointCreatedResponse(WebhookEndpointResponse):
    signing_secret: str  # Only on create and rotate

class WebhookDeliveryResponse(BaseModel):
    id: UUID
    endpoint_id: UUID | None
    job_id: UUID | None
    event_type: str
    status: str
    attempts: int
    last_attempt_at: datetime | None
    last_status_code: int | None
    last_error: str | None
    created_at: datetime

class DeliveryListResponse(BaseModel):
    deliveries: list[WebhookDeliveryResponse]
    total: int
    limit: int
    offset: int
```

All endpoints use a `RequireWebhooks` dependency (similar to existing `RequireJobsRead`).

Register in `dalston/gateway/api/v1/router.py` alongside existing routers.

---

### 4. `dalston/orchestrator/delivery.py` — Delivery Worker

```python
RETRY_DELAYS = [0, 30, 120, 600, 3600]  # seconds
MAX_ATTEMPTS = 5
POLL_INTERVAL = 2.0
MAX_CONCURRENT = 10

class DeliveryWorker:
    """Polls webhook_deliveries for pending rows and delivers them."""

    def __init__(self, session_factory, webhook_service: WebhookService):
        self._session_factory = session_factory
        self._webhook_service = webhook_service
        self._running = False

    async def start(self):
        """Run polling loop as asyncio task."""
        self._running = True
        while self._running:
            await self._poll_and_deliver()
            await asyncio.sleep(POLL_INTERVAL)

    async def _poll_and_deliver(self):
        """
        SELECT id, endpoint_id, payload, url_override, attempts
        FROM webhook_deliveries
        WHERE status = 'pending' AND next_retry_at <= now()
        ORDER BY next_retry_at
        LIMIT {MAX_CONCURRENT}
        FOR UPDATE SKIP LOCKED
        """
        # For each row:
        # - Look up endpoint for signing_secret and url
        #   (or use global secret + url_override for legacy per-job webhooks)
        # - Call webhook_service.deliver(url, payload, secret)
        # - On success: update status='success', last_attempt_at, last_status_code
        # - On failure:
        #     if attempts < MAX_ATTEMPTS:
        #         update attempts++, next_retry_at = now() + RETRY_DELAYS[attempts]
        #     else:
        #         update status='failed'

    async def stop(self):
        self._running = False
```

Changes to `dalston/orchestrator/main.py`:
- Start `DeliveryWorker` as background task alongside event listener
- Replace `_handle_job_webhook()` direct-delivery with delivery row insertion
- On `job.completed` / `job.failed`:
  1. Query matching `webhook_endpoints` for tenant
  2. Insert `webhook_deliveries` rows (one per endpoint)
  3. If `job.webhook_url` set: insert row with `url_override`, `endpoint_id=NULL`

---

### 5. `dalston/gateway/services/webhook.py` — Refactor Signing

Change `WebhookService.sign_payload()` and `deliver()` to accept `secret` as
a parameter rather than only using `self.secret`. Keep `self.secret` as fallback
for backward compat (per-job webhooks using global `WEBHOOK_SECRET`).

Add `X-Dalston-Webhook-Id` header containing the delivery UUID.

---

### 6. `dalston/gateway/api/v1/transcription.py` — Deprecation Check

```python
if webhook_url and not settings.allow_per_job_webhooks:
    raise HTTPException(
        status_code=400,
        detail="Per-job webhook_url is disabled. "
               "Register webhook endpoints via POST /v1/webhooks instead.",
    )

if webhook_url:
    logger.warning(
        "per_job_webhook_deprecated",
        job_id=str(job.id),
        message="Per-job webhook_url is deprecated. Use registered webhook endpoints.",
    )
```

Add to `dalston/config.py`:

```python
allow_per_job_webhooks: bool = Field(
    default=True,
    alias="ALLOW_PER_JOB_WEBHOOKS",
    description="Allow webhook_url parameter on job submission (legacy behavior)",
)
```

---

## Testing

### Unit Tests

**`tests/unit/test_webhook_endpoints.py`:**

- CRUD: create, list, get, update, delete
- Validation: invalid URLs (SSRF), invalid event types, missing required fields
- Secret generation: `whsec_` prefix, uniqueness
- Secret rotation: new secret different from old
- Delivery listing: pagination, status filter
- Retry: can retry `failed`, cannot retry `pending` or `success`

**`tests/unit/test_delivery_worker.py`:**

- Delivery row picked up and delivered
- Successful delivery → status='success'
- Failed delivery → retry with correct delay
- Max retries exhausted → status='failed'
- Per-job webhook (url_override) uses global secret
- SKIP LOCKED prevents duplicate processing

### Integration Tests

**`tests/integration/test_webhook_admin_api.py`:**

- All CRUD endpoints return correct status codes and shapes
- `signing_secret` only in create and rotate responses
- `webhooks` scope required (403 without it)
- Tenant isolation (cannot see other tenant's endpoints)

**`tests/integration/test_admin_webhooks_e2e.py`:**

- Register 2 endpoints → submit job → complete → both receive webhooks
- Signatures verify correctly with per-endpoint secrets
- Delivery log shows success for both
- Unreachable endpoint → retries → eventually failed → manual retry works
- Per-job `webhook_url` + registered endpoints → all receive webhooks
- `ALLOW_PER_JOB_WEBHOOKS=false` → rejects webhook_url parameter

---

## File Change Summary

| File | Action | Description |
|------|--------|-------------|
| `dalston/db/models.py` | Modify | Add WebhookEndpointModel, WebhookDeliveryModel |
| `alembic/versions/YYYYMMDD_..._add_webhook_endpoints.py` | Create | Migration for both tables + indexes |
| `dalston/config.py` | Modify | Add `allow_per_job_webhooks` setting |
| `dalston/gateway/services/webhook_endpoints.py` | Create | CRUD service |
| `dalston/gateway/services/webhook.py` | Modify | Per-endpoint secret support |
| `dalston/gateway/api/v1/webhooks.py` | Create | Router with all endpoints |
| `dalston/gateway/api/v1/router.py` | Modify | Register webhooks router |
| `dalston/gateway/dependencies.py` | Modify | Add service + auth dependencies |
| `dalston/gateway/models/responses.py` | Modify | Add response models |
| `dalston/orchestrator/delivery.py` | Create | DeliveryWorker |
| `dalston/orchestrator/main.py` | Modify | Integrate worker, change dispatch |
| `dalston/gateway/api/v1/transcription.py` | Modify | Deprecation check |
| `sdk/dalston_sdk/webhook.py` | Modify | Update docs |
| `tests/unit/test_webhook_endpoints.py` | Create | CRUD service tests |
| `tests/unit/test_delivery_worker.py` | Create | Delivery worker tests |
| `tests/integration/test_webhook_admin_api.py` | Create | API tests |
| `tests/integration/test_admin_webhooks_e2e.py` | Create | E2E tests |

---

## Implementation Order

1. **Database models + migration** — foundation, no behavior change
2. **CRUD service** — business logic, unit-testable in isolation
3. **API router + dependencies** — wires service to HTTP, integration-testable
4. **Delivery worker + orchestrator changes** — replaces in-memory delivery
5. **Deprecation check on transcription endpoint** — small, safe
6. **SDK + docs updates** — non-code
7. **E2E integration test** — validates full flow
8. **Run full test suite** — verify no regressions

---

## Rollout

1. Deploy with `ALLOW_PER_JOB_WEBHOOKS=true` (default, no behavior change)
2. Admins register endpoints via API
3. Both per-job and registered webhooks fire in parallel
4. Once all consumers migrated, set `ALLOW_PER_JOB_WEBHOOKS=false`
5. Eventually remove per-job webhook code in a future milestone
