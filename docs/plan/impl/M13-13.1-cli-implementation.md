# M13 Implementation: CLI Client

This document provides implementation details for M13: CLI Client.

---

## Package Structure

```text
cli/
├── pyproject.toml
├── README.md
├── dalston_cli/
│   ├── __init__.py          # Version info
│   ├── main.py              # CLI entry point
│   ├── commands/
│   │   ├── __init__.py
│   │   ├── transcribe.py
│   │   ├── listen.py
│   │   ├── jobs.py
│   │   ├── export.py
│   │   └── status.py
│   ├── audio.py             # Microphone capture
│   ├── output.py            # Output formatting
│   └── config.py            # Configuration loading
└── tests/
    ├── test_transcribe.py
    ├── test_listen.py
    └── test_output.py
```

---

## pyproject.toml

```toml
[project]
name = "dalston-cli"
version = "0.1.0"
description = "Command-line client for Dalston transcription server"
requires-python = ">=3.10"
dependencies = [
    "dalston-sdk>=0.1.0",
    "click>=8.1",
    "rich>=13.0",
    "sounddevice>=0.4",
]

[project.optional-dependencies]
dev = ["pytest", "pytest-asyncio"]

[project.scripts]
dalston = "dalston_cli.main:cli"
```

---

## CLI Entry Point

```python
# dalston_cli/main.py
import click
from dalston import Dalston
from dalston_cli.config import load_config

@click.group()
@click.option('--server', '-s', envvar='DALSTON_SERVER', default='http://localhost:8000')
@click.option('--api-key', '-k', envvar='DALSTON_API_KEY', default=None)
@click.option('--verbose', '-v', is_flag=True)
@click.option('--quiet', '-q', is_flag=True)
@click.version_option()
@click.pass_context
def cli(ctx, server, api_key, verbose, quiet):
    """Dalston CLI - Audio transcription from the command line."""
    ctx.ensure_object(dict)
    ctx.obj['client'] = Dalston(base_url=server, api_key=api_key)
    ctx.obj['verbose'] = verbose
    ctx.obj['quiet'] = quiet

from dalston_cli.commands import transcribe, listen, jobs, export, status
cli.add_command(transcribe.transcribe)
cli.add_command(listen.listen)
cli.add_command(jobs.jobs)
cli.add_command(export.export)
cli.add_command(status.status)
```

---

## Transcribe Command

```python
# dalston_cli/commands/transcribe.py
import click
from pathlib import Path
from dalston import SpeakerDetection, ExportFormat
from dalston_cli.output import output_job_created, output_transcript, wait_with_progress

@click.command()
@click.argument('files', nargs=-1, required=True)
@click.option('--language', '-l', default='auto')
@click.option('--output', '-o', type=click.Path())
@click.option('--format', '-f', 'fmt', default='txt',
              type=click.Choice(['txt', 'json', 'srt', 'vtt']))
@click.option('--wait/--no-wait', '-w', default=True)
@click.option('--json', 'json_output', is_flag=True)
@click.option('--speakers', default='none',
              type=click.Choice(['none', 'diarize', 'per-channel']))
@click.option('--num-speakers', type=click.IntRange(1, 32))
@click.option('--timestamps', default='word',
              type=click.Choice(['none', 'segment', 'word']))
@click.option('--no-speakers', is_flag=True)
@click.pass_context
def transcribe(ctx, files, language, output, fmt, wait, json_output,
               speakers, num_speakers, timestamps, no_speakers):
    """Transcribe audio files."""
    client = ctx.obj['client']
    quiet = ctx.obj['quiet']

    speaker_detection = {
        'none': SpeakerDetection.NONE,
        'diarize': SpeakerDetection.DIARIZE,
        'per-channel': SpeakerDetection.PER_CHANNEL,
    }[speakers]

    for file_path in files:
        # Submit job
        job = client.transcribe(
            file=file_path,
            language=language,
            speaker_detection=speaker_detection,
            num_speakers=num_speakers,
            timestamps_granularity=timestamps,
        )

        if not wait or json_output:
            output_job_created(job, json_output)
            if not wait:
                continue

        # Wait with progress
        result = wait_with_progress(client, job.id, quiet)

        if result.status == 'failed':
            raise click.ClickException(f"Transcription failed: {result.error}")

        # Output result
        if json_output:
            output_transcript(result, 'json', output)
        else:
            output_transcript(result, fmt, output, include_speakers=not no_speakers)
```

---

## Listen Command

```python
# dalston_cli/commands/listen.py
import click
import sys
from dalston import RealtimeSession, AudioEncoding
from dalston_cli.audio import MicrophoneStream
from dalston_cli.output import LiveOutputHandler, JsonlOutputHandler

@click.command()
@click.option('--language', '-l', default='auto')
@click.option('--output', '-o', type=click.Path())
@click.option('--format', '-f', 'fmt', default='live',
              type=click.Choice(['live', 'json', 'jsonl']))
@click.option('--model', '-m', default='fast', type=click.Choice(['fast', 'accurate']))
@click.option('--device', '-d')
@click.option('--list-devices', is_flag=True)
@click.option('--no-interim', is_flag=True)
@click.option('--no-vad', is_flag=True)
@click.option('--enhance', is_flag=True)
@click.pass_context
def listen(ctx, language, output, fmt, model, device, list_devices,
           no_interim, no_vad, enhance):
    """Real-time transcription from microphone."""

    if list_devices:
        for d in MicrophoneStream.list_devices():
            click.echo(f"{d['index']}: {d['name']}")
        return

    client = ctx.obj['client']
    ws_url = client.base_url.replace('http://', 'ws://').replace('https://', 'wss://')

    # Resolve device
    device_id = resolve_device(device) if device else None

    # Create output handler
    if fmt == 'live':
        handler = LiveOutputHandler(output, show_interim=not no_interim)
    elif fmt == 'jsonl':
        handler = JsonlOutputHandler(output)
    else:
        handler = JsonOutputHandler(output)

    session = RealtimeSession(
        base_url=ws_url,
        api_key=client.api_key,
        language=language,
        model=model,
        enable_vad=not no_vad,
        interim_results=not no_interim,
        enhance_on_end=enhance,
    )

    @session.on_partial
    def on_partial(text, start, end):
        handler.partial(text, start)

    @session.on_final
    def on_final(text, start, end, confidence, words):
        handler.final(text, start, end, confidence)

    @session.on_session_end
    def on_end(session_id, transcript, duration, speech_duration, enhancement_job_id):
        handler.session_end(duration, speech_duration, enhancement_job_id)

    click.echo("[Listening... Press Ctrl+C to stop]\n", err=True)

    try:
        with session, MicrophoneStream(device=device_id) as mic:
            while True:
                chunk = mic.read()
                session.send_audio(chunk)
    except KeyboardInterrupt:
        session.close()


def resolve_device(device_str):
    """Resolve device by name or index."""
    try:
        return int(device_str)
    except ValueError:
        devices = MicrophoneStream.list_devices()
        for d in devices:
            if device_str.lower() in d['name'].lower():
                return d['index']
        raise click.ClickException(f"Device not found: {device_str}")
```

---

## Audio Capture Module

```python
# dalston_cli/audio.py
import queue
import sounddevice as sd

class MicrophoneStream:
    """Cross-platform microphone capture using sounddevice/PortAudio."""

    def __init__(self, device=None, sample_rate=16000, chunk_ms=100):
        self.device = device
        self.sample_rate = sample_rate
        self.chunk_size = int(sample_rate * chunk_ms / 1000)
        self._stream = None
        self._queue = queue.Queue()

    def __enter__(self):
        self._stream = sd.InputStream(
            device=self.device,
            samplerate=self.sample_rate,
            channels=1,
            dtype='int16',
            blocksize=self.chunk_size,
            callback=self._callback,
        )
        self._stream.start()
        return self

    def __exit__(self, *args):
        if self._stream:
            self._stream.stop()
            self._stream.close()

    def _callback(self, indata, frames, time, status):
        if status:
            pass  # Could log status warnings
        self._queue.put(indata.tobytes())

    def read(self, timeout=None) -> bytes:
        """Read next audio chunk. Blocks until available."""
        return self._queue.get(timeout=timeout)

    @staticmethod
    def list_devices() -> list[dict]:
        """List available audio input devices."""
        devices = sd.query_devices()
        return [
            {
                'index': i,
                'name': d['name'],
                'channels': d['max_input_channels'],
                'sample_rate': d['default_samplerate'],
            }
            for i, d in enumerate(devices)
            if d['max_input_channels'] > 0
        ]

    @staticmethod
    def get_default_device() -> dict | None:
        """Get default input device info."""
        try:
            idx = sd.default.device[0]
            if idx is not None:
                d = sd.query_devices(idx)
                return {
                    'index': idx,
                    'name': d['name'],
                    'channels': d['max_input_channels'],
                }
        except Exception:
            pass
        return None
```

---

## Output Formatting Module

```python
# dalston_cli/output.py
import json
import sys
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

console = Console()
error_console = Console(stderr=True)


def output_job_created(job, as_json=False):
    """Output job submission result."""
    if as_json:
        console.print_json(data={
            'id': str(job.id),
            'status': job.status,
            'created_at': job.created_at.isoformat(),
        })
    else:
        console.print(f"Job submitted: {job.id}")


def output_transcript(result, fmt, output_path, include_speakers=True):
    """Output transcript in specified format."""
    if fmt == 'json':
        content = json.dumps(result.model_dump(), indent=2, default=str)
    elif fmt == 'txt':
        content = result.transcript.text
    elif fmt in ('srt', 'vtt'):
        # Use SDK export
        content = result.export(fmt, include_speakers=include_speakers)
    else:
        content = result.transcript.text

    if output_path:
        Path(output_path).write_text(content)
        error_console.print(f"Written to {output_path}")
    else:
        console.print(content)


def wait_with_progress(client, job_id, quiet=False):
    """Wait for job completion with progress display."""
    if quiet:
        return client.wait_for_completion(job_id)

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=error_console,
    ) as progress:
        task = progress.add_task("Processing...", total=None)

        while True:
            job = client.get_job(job_id)

            if job.progress is not None:
                progress.update(task,
                    description=f"{job.current_stage or 'Processing'}... {job.progress}%")

            if job.status in ('completed', 'failed', 'cancelled'):
                break

            import time
            time.sleep(1)

    return job


def output_jobs_table(jobs, as_json=False):
    """Display jobs list."""
    if as_json:
        console.print_json(data=[j.model_dump() for j in jobs])
        return

    table = Table()
    table.add_column("ID", style="cyan")
    table.add_column("Status")
    table.add_column("Created")
    table.add_column("Duration")

    for job in jobs:
        status_style = {
            'completed': 'green',
            'running': 'yellow',
            'pending': 'dim',
            'failed': 'red',
        }.get(job.status, '')

        table.add_row(
            str(job.id)[:12],
            f"[{status_style}]{job.status}[/]",
            job.created_at.strftime("%Y-%m-%d %H:%M"),
            format_duration(job.duration) if job.duration else "-",
        )

    console.print(table)


def format_duration(seconds):
    """Format duration as human-readable string."""
    if seconds < 60:
        return f"{seconds:.0f}s"
    elif seconds < 3600:
        return f"{seconds // 60:.0f}m {seconds % 60:.0f}s"
    else:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours:.0f}h {minutes:.0f}m"


class LiveOutputHandler:
    """Handler for live human-readable output."""

    def __init__(self, output_path=None, show_interim=True):
        self.output_path = output_path
        self.show_interim = show_interim
        self.file = open(output_path, 'a') if output_path else None
        self._last_partial = ""

    def partial(self, text, start):
        if self.show_interim:
            # Clear previous partial, show new one
            clear = '\r' + ' ' * len(self._last_partial) + '\r'
            timestamp = f"[{self._format_time(start)}]"
            line = f"{timestamp} {text}..."
            sys.stderr.write(clear + line)
            sys.stderr.flush()
            self._last_partial = line

    def final(self, text, start, end, confidence):
        # Clear partial line
        if self._last_partial:
            sys.stderr.write('\r' + ' ' * len(self._last_partial) + '\r')
            self._last_partial = ""

        timestamp = f"[{self._format_time(start)}]"
        line = f"{timestamp} {text}"
        console.print(line)

        if self.file:
            self.file.write(text + '\n')
            self.file.flush()

    def session_end(self, duration, speech_duration, enhancement_job_id):
        error_console.print(
            f"\n[Session ended: {duration:.1f}s total, {speech_duration:.1f}s speech]"
        )
        if enhancement_job_id:
            error_console.print(f"Enhancement job: {enhancement_job_id}")

        if self.file:
            self.file.close()

    def _format_time(self, seconds):
        mins = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{mins:02d}:{secs:02d}"


class JsonlOutputHandler:
    """Handler for JSON Lines output."""

    def __init__(self, output_path=None):
        self.file = open(output_path, 'a') if output_path else sys.stdout

    def partial(self, text, start):
        pass  # Skip partials in JSONL mode

    def final(self, text, start, end, confidence):
        obj = {
            'type': 'final',
            'text': text,
            'start': start,
            'end': end,
            'confidence': confidence,
        }
        self.file.write(json.dumps(obj) + '\n')
        self.file.flush()

    def session_end(self, duration, speech_duration, enhancement_job_id):
        obj = {
            'type': 'session_end',
            'duration': duration,
            'speech_duration': speech_duration,
        }
        if enhancement_job_id:
            obj['enhancement_job_id'] = enhancement_job_id
        self.file.write(json.dumps(obj) + '\n')

        if self.file != sys.stdout:
            self.file.close()
```

---

## Jobs Command

```python
# dalston_cli/commands/jobs.py
import click
from dalston_cli.output import output_jobs_table, output_transcript, wait_with_progress

@click.group()
def jobs():
    """Manage transcription jobs."""
    pass


@jobs.command('list')
@click.option('--status', type=click.Choice(['pending', 'running', 'completed', 'failed']))
@click.option('--limit', default=20, type=click.IntRange(1, 100))
@click.option('--json', 'as_json', is_flag=True)
@click.pass_context
def list_jobs(ctx, status, limit, as_json):
    """List transcription jobs."""
    client = ctx.obj['client']
    jobs_list = client.list_jobs(status=status, limit=limit)
    output_jobs_table(jobs_list.jobs, as_json=as_json)


@jobs.command('get')
@click.argument('job_id')
@click.option('--json', 'as_json', is_flag=True)
@click.pass_context
def get_job(ctx, job_id, as_json):
    """Get job details."""
    client = ctx.obj['client']
    job = client.get_job(job_id)

    if as_json:
        click.echo(job.model_dump_json(indent=2))
    else:
        click.echo(f"ID:       {job.id}")
        click.echo(f"Status:   {job.status}")
        click.echo(f"Created:  {job.created_at}")
        if job.language_code:
            click.echo(f"Language: {job.language_code}")
        if job.duration:
            click.echo(f"Duration: {job.duration:.1f}s")


@jobs.command('cancel')
@click.argument('job_id')
@click.pass_context
def cancel_job(ctx, job_id):
    """Cancel a job."""
    client = ctx.obj['client']
    client.cancel_job(job_id)
    click.echo(f"Job {job_id} cancelled")


@jobs.command('wait')
@click.argument('job_id')
@click.option('--timeout', default=300, type=int)
@click.option('--format', '-f', 'fmt', default='txt',
              type=click.Choice(['txt', 'json', 'srt', 'vtt']))
@click.option('--output', '-o', type=click.Path())
@click.pass_context
def wait_job(ctx, job_id, timeout, fmt, output):
    """Wait for job completion."""
    client = ctx.obj['client']
    quiet = ctx.obj['quiet']

    result = wait_with_progress(client, job_id, quiet)

    if result.status == 'failed':
        raise click.ClickException(f"Job failed: {result.error}")

    output_transcript(result, fmt, output)
```

---

## Export Command

```python
# dalston_cli/commands/export.py
import click

@click.command()
@click.argument('job_id')
@click.option('--format', '-f', 'fmt', default='txt',
              type=click.Choice(['txt', 'json', 'srt', 'vtt']))
@click.option('--output', '-o', type=click.Path())
@click.option('--no-speakers', is_flag=True)
@click.option('--max-line-length', default=42, type=click.IntRange(10, 200))
@click.option('--max-lines', default=2, type=click.IntRange(1, 10))
@click.pass_context
def export(ctx, job_id, fmt, output, no_speakers, max_line_length, max_lines):
    """Export transcript in various formats."""
    client = ctx.obj['client']

    content = client.export(
        job_id,
        format=fmt,
        include_speakers=not no_speakers,
        max_line_length=max_line_length,
        max_lines=max_lines,
    )

    if output:
        from pathlib import Path
        Path(output).write_text(content)
        click.echo(f"Written to {output}", err=True)
    else:
        click.echo(content)
```

---

## Status Command

```python
# dalston_cli/commands/status.py
import click
from rich.console import Console

console = Console()

@click.command()
@click.option('--json', 'as_json', is_flag=True)
@click.pass_context
def status(ctx, as_json):
    """Show server and system status."""
    client = ctx.obj['client']

    try:
        health = client.health()
        realtime = client.get_realtime_status()
    except Exception as e:
        if as_json:
            click.echo('{"healthy": false, "error": "' + str(e) + '"}')
        else:
            console.print(f"[red]Server unreachable:[/red] {e}")
        ctx.exit(4)

    if as_json:
        import json
        data = {
            'server': client.base_url,
            'healthy': True,
            'batch': {'queue_depth': health.get('queue_depth', 0)},
            'realtime': {
                'status': realtime.status,
                'active_sessions': realtime.active_sessions,
                'total_capacity': realtime.total_capacity,
                'available_capacity': realtime.available_capacity,
                'workers': realtime.worker_count,
            }
        }
        click.echo(json.dumps(data, indent=2))
    else:
        console.print(f"Server: {client.base_url} [green]✓[/green]\n")

        console.print("Batch Processing:")
        console.print(f"  Queue depth: {health.get('queue_depth', 0)} jobs pending\n")

        console.print("Real-time:")
        console.print(f"  Status: {realtime.status}")
        console.print(f"  Capacity: {realtime.active_sessions}/{realtime.total_capacity} sessions "
                      f"({realtime.available_capacity} available)")
        console.print(f"  Workers: {realtime.worker_count} active")
```

---

## Configuration Module

```python
# dalston_cli/config.py
from pathlib import Path
import os

def load_config() -> dict:
    """Load configuration from file and environment."""
    config = {
        'server': 'http://localhost:8000',
        'api_key': None,
        'defaults': {
            'language': 'auto',
            'format': 'txt',
            'speakers': 'none',
        }
    }

    # Load from config file
    config_path = Path.home() / '.dalston' / 'config.yaml'
    if config_path.exists():
        try:
            import yaml
            with open(config_path) as f:
                file_config = yaml.safe_load(f)
                if file_config:
                    config.update(file_config)
        except Exception:
            pass  # Ignore config file errors

    # Override with environment variables
    if os.environ.get('DALSTON_SERVER'):
        config['server'] = os.environ['DALSTON_SERVER']
    if os.environ.get('DALSTON_API_KEY'):
        config['api_key'] = os.environ['DALSTON_API_KEY']

    return config
```

---

## Testing

```python
# tests/test_transcribe.py
from click.testing import CliRunner
from dalston_cli.main import cli

def test_transcribe_help():
    runner = CliRunner()
    result = runner.invoke(cli, ['transcribe', '--help'])
    assert result.exit_code == 0
    assert 'Transcribe audio files' in result.output

def test_transcribe_no_args():
    runner = CliRunner()
    result = runner.invoke(cli, ['transcribe'])
    assert result.exit_code == 2  # Missing required argument
```

```python
# tests/test_audio.py
import pytest
from dalston_cli.audio import MicrophoneStream

def test_list_devices():
    # This should not fail even with no audio devices
    devices = MicrophoneStream.list_devices()
    assert isinstance(devices, list)
```
