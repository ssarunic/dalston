# M06 Task 6.1 + 6.2: Realtime SDK & Session Router - Implementation Plan

## Overview

This plan covers the implementation of:

- **`dalston/realtime_sdk/`** - SDK for building real-time streaming transcription engines
- **`dalston/session_router/`** - Worker pool management and session allocation

These components are implemented together since they are interdependent: the SDK's `WorkerRegistry` writes to Redis keys that the Session Router reads.

The SDK follows the same patterns established in `dalston/engine_sdk/` but is designed for WebSocket-based real-time processing instead of Redis queue-based batch processing.

## Goal

Provide a clean, well-documented SDK that enables developers to create real-time transcription workers with minimal boilerplate, handling:

- WebSocket server lifecycle
- Session management
- Voice Activity Detection (VAD)
- Transcript assembly
- Worker registration with Session Router
- Audio encoding conversion (μ-law, A-law, PCM variants)

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            REALTIME SDK                                          │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                     RealtimeEngine (base.py)                            │   │
│   │                                                                          │   │
│   │   Abstract base class - engine implementers subclass this               │   │
│   │   • load_models()   - Load ASR models into GPU memory                   │   │
│   │   • transcribe()    - Transcribe audio chunk                            │   │
│   │   • run()           - Start WebSocket server + heartbeat loop           │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                       │                                          │
│                                       │ creates                                  │
│                                       ▼                                          │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                     SessionHandler (session.py)                         │   │
│   │                                                                          │   │
│   │   Manages one WebSocket session                                         │   │
│   │   • Audio buffer management                                             │   │
│   │   • VAD integration (speech detection)                                  │   │
│   │   • ASR triggering (calls engine.transcribe)                            │   │
│   │   • Transcript assembly                                                 │   │
│   │   • Protocol message sending                                            │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                       │                                          │
│                 ┌─────────────────────┼─────────────────────┐                   │
│                 │                     │                     │                   │
│                 ▼                     ▼                     ▼                   │
│   ┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────────┐       │
│   │   VADProcessor      │ │ TranscriptAssembler │ │    AudioBuffer      │       │
│   │     (vad.py)        │ │   (assembler.py)    │ │   (session.py)      │       │
│   │                     │ │                     │ │                     │       │
│   │ • Silero VAD        │ │ • Segment tracking  │ │ • PCM buffering     │       │
│   │ • Speech detection  │ │ • Timestamp adjust  │ │ • Chunk extraction  │       │
│   │ • Endpoint detect   │ │ • Full transcript   │ │ • Encoding support  │       │
│   └─────────────────────┘ └─────────────────────┘ └─────────────────────┘       │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                     WorkerRegistry (registry.py)                        │   │
│   │                                                                          │   │
│   │   Redis client for Session Router communication                         │   │
│   │   • register_worker()     - Register on startup                         │   │
│   │   • heartbeat()           - Periodic health update                      │   │
│   │   • session_started()     - Notify session begin                        │   │
│   │   • session_ended()       - Notify session end                          │   │
│   │   • unregister_worker()   - Clean shutdown                              │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                     Protocol Types (protocol.py)                        │   │
│   │                                                                          │   │
│   │   Message dataclasses for WebSocket communication                       │   │
│   │   • SessionBegin, SessionEnd                                            │   │
│   │   • TranscriptPartial, TranscriptFinal                                  │   │
│   │   • VADSpeechStart, VADSpeechEnd                                        │   │
│   │   • Error                                                               │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## File Structure

```
dalston/realtime_sdk/
├── __init__.py           # Public API exports
├── base.py               # RealtimeEngine abstract base class
├── session.py            # SessionHandler, AudioBuffer, SessionConfig
├── vad.py                # VADProcessor, VADConfig, VADState, VADResult
├── assembler.py          # TranscriptAssembler, Segment, Word
├── registry.py           # WorkerRegistry client for Session Router
└── protocol.py           # Message types for WebSocket protocol
```

---

## Component Details

### 1. `protocol.py` - Message Types

Define all WebSocket protocol messages as dataclasses with JSON serialization.

```python
# Key types to implement:

@dataclass
class SessionConfig:
    language: str = "auto"
    model: str = "fast"
    encoding: str = "pcm_s16le"
    sample_rate: int = 16000
    channels: int = 1
    enable_vad: bool = True
    interim_results: bool = True
    word_timestamps: bool = False

# Server → Client messages
@dataclass
class SessionBeginMessage:
    type: str = "session.begin"
    session_id: str
    config: SessionConfig

@dataclass
class TranscriptPartialMessage:
    type: str = "transcript.partial"
    text: str
    start: float
    end: float

@dataclass
class TranscriptFinalMessage:
    type: str = "transcript.final"
    text: str
    start: float
    end: float
    confidence: float
    words: list[WordInfo] | None = None

@dataclass
class VADSpeechStartMessage:
    type: str = "vad.speech_start"
    timestamp: float

@dataclass
class VADSpeechEndMessage:
    type: str = "vad.speech_end"
    timestamp: float

@dataclass
class SessionEndMessage:
    type: str = "session.end"
    session_id: str
    total_duration: float
    total_speech_duration: float
    transcript: str
    segments: list[SegmentInfo]

@dataclass
class ErrorMessage:
    type: str = "error"
    code: str
    message: str
    recoverable: bool = True

# Client → Server messages (parsed, not sent)
@dataclass
class ConfigUpdateMessage:
    type: str = "config"
    language: str | None = None
    # ... other updatable fields

@dataclass
class FlushMessage:
    type: str = "flush"

@dataclass
class EndMessage:
    type: str = "end"
```

**Design decisions:**

- Use `dataclasses` for simplicity (consistent with engine_sdk)
- Include `to_dict()` method for JSON serialization
- Parse incoming messages via factory function `parse_client_message()`

---

### 2. `vad.py` - Voice Activity Detection

Silero VAD wrapper with endpoint detection.

```python
@dataclass
class VADConfig:
    """VAD configuration parameters."""
    speech_threshold: float = 0.5      # Probability threshold for speech
    min_speech_duration: float = 0.25  # Minimum speech duration (seconds)
    min_silence_duration: float = 0.5  # Silence duration to trigger endpoint
    sample_rate: int = 16000
    lookback_chunks: int = 3           # ~300ms lookback buffer

class VADState(Enum):
    SILENCE = "silence"
    SPEECH = "speech"

@dataclass
class VADResult:
    """Result from processing an audio chunk."""
    event: Literal["speech_start", "speech_end"] | None
    speech_audio: np.ndarray | None  # Accumulated speech on endpoint

class VADProcessor:
    """Silero VAD wrapper with endpoint detection."""

    def __init__(self, config: VADConfig = None):
        """Initialize VAD with optional custom config."""

    def process_chunk(self, audio: np.ndarray) -> VADResult:
        """Process audio chunk, detect speech boundaries."""

    def reset(self) -> None:
        """Reset state for new session."""

    def flush(self) -> np.ndarray | None:
        """Return any buffered speech audio."""
```

**Key behaviors:**

- Loads Silero VAD model lazily on first use
- Maintains lookback buffer to capture speech onset
- State machine: SILENCE → SPEECH → SILENCE
- Returns accumulated speech audio on endpoint detection
- Thread-safe model inference

---

### 3. `assembler.py` - Transcript Assembly

Builds full session transcript from utterances.

```python
@dataclass
class Word:
    """Word with timing and confidence."""
    word: str
    start: float
    end: float
    confidence: float

@dataclass
class Segment:
    """Transcribed segment (utterance)."""
    id: str
    start: float
    end: float
    text: str
    words: list[Word]
    confidence: float

class TranscriptAssembler:
    """Assembles session transcript from utterances."""

    def __init__(self):
        """Initialize empty assembler."""

    def add_utterance(
        self,
        text: str,
        words: list[Word],
        audio_duration: float,
        confidence: float
    ) -> Segment:
        """Add transcribed utterance, return segment with adjusted timestamps."""

    def get_full_transcript(self) -> str:
        """Get concatenated transcript text."""

    def get_segments(self) -> list[Segment]:
        """Get all segments."""

    @property
    def current_time(self) -> float:
        """Current session timeline position."""

    def reset(self) -> None:
        """Reset for new session."""
```

**Key behaviors:**

- Adjusts word timestamps to session timeline
- Generates sequential segment IDs
- Tracks total speech duration

---

### 4. `session.py` - Session Handler

Manages a single WebSocket session lifecycle.

```python
@dataclass
class SessionConfig:
    """Session configuration from connection parameters."""
    session_id: str
    language: str = "auto"
    model: str = "fast"
    encoding: str = "pcm_s16le"
    sample_rate: int = 16000
    channels: int = 1
    enable_vad: bool = True
    interim_results: bool = True
    word_timestamps: bool = False

class AudioBuffer:
    """Buffers incoming audio and extracts processing chunks.

    Handles encoding conversion to float32 numpy arrays suitable for
    VAD and ASR processing. Mirrors batch pipeline's audio-prepare
    normalization but for streaming audio.
    """

    # Supported encodings (matches WEBSOCKET_API.md)
    SUPPORTED_ENCODINGS = [
        "pcm_s16le",   # 16-bit signed PCM, little-endian (default)
        "pcm_f32le",   # 32-bit float PCM, little-endian
        "mulaw",       # μ-law encoded (8-bit, telephony)
        "alaw",        # A-law encoded (8-bit, telephony)
    ]

    def __init__(self, sample_rate: int, encoding: str, chunk_duration_ms: int = 100):
        """Initialize buffer with audio format.

        Args:
            sample_rate: Expected sample rate (e.g., 16000)
            encoding: Audio encoding (see SUPPORTED_ENCODINGS)
            chunk_duration_ms: Chunk size for VAD processing
        """

    def add(self, data: bytes) -> None:
        """Add raw audio bytes to buffer. Converts to float32 internally."""

    def get_chunk(self) -> np.ndarray | None:
        """Extract next processing chunk if available. Returns float32 array."""

    def flush(self) -> np.ndarray | None:
        """Return all remaining buffered audio as float32."""

    def get_total_duration(self) -> float:
        """Total audio duration received (seconds)."""

    def _decode_audio(self, data: bytes) -> np.ndarray:
        """Decode raw bytes to float32 based on encoding.

        - pcm_s16le: np.frombuffer + normalize to [-1, 1]
        - pcm_f32le: np.frombuffer directly
        - mulaw/alaw: audioop.ulaw2lin/alaw2lin + normalize
        """

class SessionHandler:
    """Handles one WebSocket transcription session."""

    def __init__(
        self,
        websocket: WebSocketServerProtocol,
        config: SessionConfig,
        transcribe_fn: Callable[[np.ndarray, str, str], TranscribeResult],
        on_session_end: Callable[[str, float, str], None] | None = None
    ):
        """
        Initialize session handler.

        Args:
            websocket: WebSocket connection
            config: Session configuration
            transcribe_fn: Callback to engine's transcribe method
            on_session_end: Optional callback when session ends
        """

    async def run(self) -> None:
        """Main session processing loop."""

    async def send(self, message: BaseMessage) -> None:
        """Send protocol message to client."""

    def get_duration(self) -> float:
        """Get session wall-clock duration."""

    @property
    def error(self) -> str | None:
        """Error message if session failed."""
```

**Key behaviors:**

- Sends `session.begin` on connection
- Processes binary frames as audio, JSON frames as control
- Integrates VAD → ASR → Assembler pipeline
- Handles `config`, `flush`, `end` control messages
- Sends `session.end` with full transcript on completion
- Graceful error handling with recoverable errors

---

### 5. `registry.py` - Worker Registry Client

Redis client for Session Router communication.

```python
@dataclass
class WorkerInfo:
    """Worker registration information."""
    worker_id: str
    endpoint: str
    capacity: int
    models: list[str]
    languages: list[str]

class WorkerRegistry:
    """Client for registering with Session Router via Redis."""

    WORKER_SET_KEY = "dalston:realtime:workers"
    WORKER_KEY_PREFIX = "dalston:realtime:worker:"
    SESSION_KEY_PREFIX = "dalston:realtime:session:"
    EVENTS_CHANNEL = "dalston:realtime:events"

    def __init__(self, redis_url: str):
        """Initialize with Redis connection URL."""

    async def register(self, info: WorkerInfo) -> None:
        """Register worker on startup."""

    async def heartbeat(
        self,
        worker_id: str,
        active_sessions: int,
        gpu_memory_used: str,
        status: str = "ready"
    ) -> None:
        """Send heartbeat update."""

    async def session_started(self, worker_id: str, session_id: str) -> None:
        """Notify Session Router that a session has started."""

    async def session_ended(
        self,
        worker_id: str,
        session_id: str,
        duration: float,
        status: str
    ) -> None:
        """Notify Session Router that a session has ended."""

    async def unregister(self, worker_id: str) -> None:
        """Unregister worker on shutdown."""

    async def close(self) -> None:
        """Close Redis connection."""
```

**Redis key patterns (from SESSION_ROUTER.md):**

```
dalston:realtime:workers                     # Set of worker IDs
dalston:realtime:worker:{worker_id}          # Hash with worker state
dalston:realtime:worker:{worker_id}:sessions # Set of active session IDs
dalston:realtime:session:{session_id}        # Hash with session state
dalston:realtime:events                      # Pub/sub for events
```

---

### 6. `base.py` - RealtimeEngine Base Class

Abstract base class that engine implementations extend.

```python
class RealtimeEngine(ABC):
    """Abstract base class for real-time transcription engines.

    Engine implementations subclass this and implement:
    - load_models(): Load ASR models into memory
    - transcribe(): Transcribe an audio segment
    - health_check(): Return health status (optional)

    The SDK handles:
    - WebSocket server lifecycle
    - Session management
    - Worker registration and heartbeat
    - Signal handling for graceful shutdown

    Example:
        class MyRealtimeEngine(RealtimeEngine):
            def load_models(self):
                self.model = WhisperModel("large-v3")

            def transcribe(self, audio, language, model_variant):
                segments, info = self.model.transcribe(audio)
                return TranscribeResult(...)

        if __name__ == "__main__":
            engine = MyRealtimeEngine()
            asyncio.run(engine.run())
    """

    def __init__(self):
        """Initialize the engine."""
        self.worker_id = os.environ.get("WORKER_ID", "realtime-worker")
        self.port = int(os.environ.get("WORKER_PORT", "9000"))
        self.max_sessions = int(os.environ.get("MAX_SESSIONS", "4"))
        self.redis_url = os.environ.get("REDIS_URL", "redis://localhost:6379")

        self._sessions: dict[str, SessionHandler] = {}
        self._registry: WorkerRegistry | None = None
        self._running = False

    @abstractmethod
    def load_models(self) -> None:
        """Load ASR models into memory.

        Called once on startup before accepting connections.
        Implement to load your models (e.g., Whisper, VAD).
        """
        raise NotImplementedError

    @abstractmethod
    def transcribe(
        self,
        audio: np.ndarray,
        language: str,
        model_variant: str
    ) -> TranscribeResult:
        """Transcribe an audio segment.

        Args:
            audio: Audio samples (numpy array, float32, mono)
            language: Language code or "auto"
            model_variant: Model variant ("fast" or "accurate")

        Returns:
            TranscribeResult with text, words, language, confidence
        """
        raise NotImplementedError

    def get_models(self) -> list[str]:
        """Return list of loaded model variants.

        Override to report available models. Default: ["fast"]
        """
        return ["fast"]

    def get_languages(self) -> list[str]:
        """Return list of supported languages.

        Override to report supported languages. Default: ["auto"]
        """
        return ["auto"]

    def get_gpu_memory_usage(self) -> str:
        """Return GPU memory usage string.

        Override to report actual GPU usage.
        """
        return "0GB"

    def health_check(self) -> dict[str, Any]:
        """Return health status for monitoring.

        Override to provide engine-specific health info.
        """
        return {
            "status": "healthy",
            "active_sessions": len(self._sessions),
            "capacity": self.max_sessions,
        }

    async def run(self) -> None:
        """Start the engine.

        This method:
        1. Loads models via load_models()
        2. Registers with Session Router
        3. Starts heartbeat loop
        4. Starts WebSocket server
        5. Runs until shutdown signal
        """

    async def shutdown(self) -> None:
        """Graceful shutdown.

        Stops accepting new sessions, waits for active sessions,
        unregisters from Session Router.
        """
```

**TranscribeResult type:**

```python
@dataclass
class TranscribeResult:
    """Result from transcription."""
    text: str
    words: list[Word]
    language: str
    confidence: float
```

---

### 7. `__init__.py` - Public API

```python
"""Dalston Realtime SDK for streaming transcription engines.

This SDK provides the foundation for building real-time transcription
workers that integrate with the Dalston real-time infrastructure.

Example usage:
    from dalston.realtime_sdk import RealtimeEngine, TranscribeResult

    class MyEngine(RealtimeEngine):
        def load_models(self):
            self.model = load_whisper_model()

        def transcribe(self, audio, language, model_variant):
            result = self.model.transcribe(audio)
            return TranscribeResult(text=result.text, ...)

    if __name__ == "__main__":
        import asyncio
        engine = MyEngine()
        asyncio.run(engine.run())

Environment variables:
    WORKER_ID: Unique identifier for this worker
    WORKER_PORT: WebSocket server port (default: 9000)
    MAX_SESSIONS: Maximum concurrent sessions (default: 4)
    REDIS_URL: Redis connection URL (default: redis://localhost:6379)
"""

from dalston.realtime_sdk.base import RealtimeEngine, TranscribeResult
from dalston.realtime_sdk.session import SessionHandler, SessionConfig, AudioBuffer
from dalston.realtime_sdk.vad import VADProcessor, VADConfig, VADResult
from dalston.realtime_sdk.assembler import TranscriptAssembler, Segment, Word
from dalston.realtime_sdk.registry import WorkerRegistry, WorkerInfo
from dalston.realtime_sdk.protocol import (
    SessionBeginMessage,
    SessionEndMessage,
    TranscriptPartialMessage,
    TranscriptFinalMessage,
    VADSpeechStartMessage,
    VADSpeechEndMessage,
    ErrorMessage,
)

__all__ = [
    # Core
    "RealtimeEngine",
    "TranscribeResult",
    # Session
    "SessionHandler",
    "SessionConfig",
    "AudioBuffer",
    # VAD
    "VADProcessor",
    "VADConfig",
    "VADResult",
    # Assembler
    "TranscriptAssembler",
    "Segment",
    "Word",
    # Registry
    "WorkerRegistry",
    "WorkerInfo",
    # Protocol
    "SessionBeginMessage",
    "SessionEndMessage",
    "TranscriptPartialMessage",
    "TranscriptFinalMessage",
    "VADSpeechStartMessage",
    "VADSpeechEndMessage",
    "ErrorMessage",
]
```

---

---

## Session Router (Task 6.2)

The Session Router manages the real-time worker pool, allocating sessions to workers with available capacity.

### File Structure

```text
dalston/session_router/
├── __init__.py           # Public API exports
├── router.py             # Main SessionRouter class
├── registry.py           # WorkerRegistry (read-side, tracks workers)
├── allocator.py          # Session allocation logic
└── health.py             # Health check loop
```

### Components

#### `registry.py` - Worker Registry (Server-Side)

Reads worker state from Redis (written by SDK's `WorkerRegistry` client).

```python
class WorkerRegistry:
    """Server-side registry that tracks worker pool state."""

    async def get_workers(self) -> list[WorkerState]:
        """Get all registered workers."""

    async def get_worker(self, worker_id: str) -> WorkerState | None:
        """Get specific worker state."""

    async def get_available_workers(
        self,
        model: str,
        language: str
    ) -> list[WorkerState]:
        """Get workers with capacity that support requested model/language."""

    async def mark_worker_offline(self, worker_id: str) -> None:
        """Mark worker as offline (stale heartbeat)."""
```

#### `allocator.py` - Session Allocator

Implements least-loaded allocation strategy.

```python
class SessionAllocator:
    """Allocates sessions to workers."""

    async def acquire_worker(
        self,
        language: str,
        model: str,
        client_ip: str
    ) -> WorkerAllocation | None:
        """
        Find worker with capacity, reserve slot atomically.

        Returns:
            WorkerAllocation with worker_id, endpoint, session_id
            None if no capacity available
        """

    async def release_worker(self, session_id: str) -> None:
        """Release capacity when session ends."""
```

**Allocation algorithm:**

1. Get all workers from registry
2. Filter by status (ready or busy, not draining/offline)
3. Filter by capacity (active_sessions < capacity)
4. Filter by model support
5. Filter by language support
6. Select worker with most available slots (least-loaded)
7. Atomically increment active_sessions via Redis HINCRBY
8. Create session record in Redis
9. Return allocation

#### `health.py` - Health Monitor

Background loop checking worker heartbeats.

```python
class HealthMonitor:
    """Monitors worker health via heartbeat timeout."""

    HEARTBEAT_TIMEOUT = 30  # seconds

    async def run(self) -> None:
        """Run health check loop every 10 seconds."""

    async def check_workers(self) -> None:
        """Check all workers, mark stale ones offline."""
```

#### `router.py` - Main Router

Combines components and provides public API.

```python
class SessionRouter:
    """Main session router coordinating worker pool."""

    def __init__(self, redis_url: str):
        self.registry = WorkerRegistry(redis_url)
        self.allocator = SessionAllocator(self.registry)
        self.health = HealthMonitor(self.registry)

    async def start(self) -> None:
        """Start health monitor background task."""

    async def stop(self) -> None:
        """Stop health monitor."""

    async def acquire_worker(
        self,
        language: str,
        model: str,
        client_ip: str
    ) -> WorkerAllocation | None:
        """Acquire worker for new session."""

    async def release_worker(self, session_id: str) -> None:
        """Release worker when session ends."""

    async def list_workers(self) -> list[WorkerStatus]:
        """List all workers with status."""

    async def get_capacity(self) -> CapacityInfo:
        """Get total/available capacity."""
```

### Redis Key Contracts

Both SDK and Session Router use these keys:

| Key | Type | Writer | Reader |
|-----|------|--------|--------|
| `dalston:realtime:workers` | Set | SDK | Router |
| `dalston:realtime:worker:{id}` | Hash | SDK | Router |
| `dalston:realtime:worker:{id}:sessions` | Set | SDK | Router |
| `dalston:realtime:session:{id}` | Hash | Router | Both |
| `dalston:realtime:events` | PubSub | Both | Both |

### Deployment Mode

Session Router runs **embedded in Gateway** for simplicity (single process). Can be extracted to separate service later if needed.

```python
# gateway/main.py
from dalston.session_router import SessionRouter

router = SessionRouter(redis_url=settings.redis_url)

@app.on_event("startup")
async def startup():
    await router.start()

@app.on_event("shutdown")
async def shutdown():
    await router.stop()
```

---

## Implementation Order

**Phase 1: Core Types (no dependencies)**

1. `realtime_sdk/protocol.py` - Message types
2. `realtime_sdk/assembler.py` - Transcript assembly

**Phase 2: Independent Components**

3. `realtime_sdk/vad.py` - VAD processor (numpy, torch)
4. `realtime_sdk/registry.py` - Worker registry client (redis.asyncio)
5. `session_router/registry.py` - Worker registry server-side
6. `session_router/allocator.py` - Session allocation

**Phase 3: Integration**

7. `session_router/health.py` - Health monitor
8. `session_router/router.py` - Main router class
9. `realtime_sdk/session.py` - Session handler
10. `realtime_sdk/base.py` - RealtimeEngine base class

**Phase 4: Exports**

11. `realtime_sdk/__init__.py` - Public exports
12. `session_router/__init__.py` - Public exports

---

## Dependencies

Add to `pyproject.toml`:

```toml
[project.optional-dependencies]
realtime-sdk = [
    "websockets>=12.0",
    "redis>=5.0.0",
    "numpy>=1.24.0",
    "torch>=2.0.0",  # For Silero VAD
]
```

---

## Testing Strategy

### Unit Tests

```
tests/unit/realtime_sdk/
├── test_protocol.py      # Message serialization
├── test_vad.py           # VAD state machine, endpoint detection
├── test_assembler.py     # Transcript assembly, timestamp adjustment
├── test_session.py       # Session lifecycle (mock WebSocket)
├── test_registry.py      # Redis operations (mock Redis)
└── test_base.py          # Engine lifecycle (mock components)
```

### Integration Tests

```
tests/integration/
└── test_realtime_sdk.py  # Full session with real VAD, mock ASR
```

### Key Test Scenarios

1. **VAD Tests:**
   - Speech detection above threshold
   - Endpoint detection after silence
   - Lookback buffer captures speech onset
   - Multiple utterances in session

2. **Session Tests:**
   - Connection → session.begin message
   - Audio → transcript.final message
   - Control messages (config, flush, end)
   - Error handling and recovery

3. **Registry Tests:**
   - Worker registration writes correct Redis keys
   - Heartbeat updates timestamp
   - Session start/end updates counts

---

## Verification Checklist

After implementation, verify:

- [ ] `RealtimeEngine` can be subclassed with just `load_models()` and `transcribe()`
- [ ] Engine starts WebSocket server and registers with Redis
- [ ] Session receives audio bytes and produces transcript messages
- [ ] VAD correctly detects speech start/end events
- [ ] Transcript assembler maintains correct session timeline
- [ ] Heartbeat updates Redis every 10 seconds
- [ ] Graceful shutdown unregisters worker
- [ ] All protocol messages serialize correctly to JSON

---

## Design Decisions

1. **Interim results**: Start with **endpoint-only** transcription for MVP. Partial results every 500ms during speech can be added in a follow-up iteration.

2. **Audio encoding**: `AudioBuffer` handles **encoding conversion out of the box** (μ-law, A-law, PCM variants → float32). This mirrors how batch pipeline uses `audio-prepare` engine with ffmpeg to normalize formats.

3. **VAD model loading**: SDK loads Silero VAD by default in `VADProcessor`. Engine can override if needed.

4. **Implementation scope**: Tasks 6.1 (SDK) and 6.2 (Session Router) are implemented together since they share Redis key contracts.

---

## Notes

- This SDK mirrors the design of `engine_sdk` but for async WebSocket operations
- The `RealtimeEngine` base class is the equivalent of `Engine` from engine_sdk
- Workers register with Session Router (to be built in 6.2) instead of polling queues
- The actual whisper-streaming engine (6.4) will use this SDK
